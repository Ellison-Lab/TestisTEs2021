from os.path import realpath
from os.path import split as pathsplit
from os.path import basename
import subprocess
from snakemake.remote.FTP import RemoteProvider as FTPRemoteProvider
from snakemake.remote.HTTP import RemoteProvider as HTTPRemoteProvider
import sys
import random


# Block annoying warnings
if not sys.warnoptions:
    import warnings
    warnings.simplefilter("ignore")

# Meta
__author__ = "Matt Lawlor"

# Setup
shell.executable("/bin/bash")


# Remotes
HTTP = HTTPRemoteProvider()
FTP = FTPRemoteProvider()

# DETERMINE REMOTE OR LOCAL RESOURCE
def determine_resource(path):
    if "ftp://" in path:
         return FTP.remote(path, immediate_close = True)
    elif "http://" in path:
         return HTTP.remote(path)
    elif "https://" in path:
         return HTTP.remote(path)
    else:
        return path

singularity: "docker://continuumio/miniconda3"
configfile: "config/config.yaml"
pepfile: "config/pep.yaml"


# variables
RANDOM_SEED = config.get("RANDOM_SEED",2020)
random.seed(RANDOM_SEED)
TOPGO_NODES = config.get("TOPGO_NODES",100)
MIN_QVAL = config.get("GRID_MIN_QVAL",0.005)
MAX_QVAL = config.get("GRID_MAX_QVAL",0.1)
STEP_QVAL = config.get("GRID_STEP_QVAL", 2)
MIN_COMPS = config.get("GRID_MIN_COMPS",20)
MAX_COMPS = config.get("GRID_MAX_COMPS",170) + 1
STEP_COMPS = config.get("GRID_STEP_COMPS", 10)
REPS = range(1,config.get("GRID_REPS",50) + 1,1)
OVERALL_REPS = range(1,config.get("GRID_OVERALL_REPS",2) + 1,1)
COMPONENTS = range(MIN_COMPS,MAX_COMPS,STEP_COMPS)
QVALS = [MIN_QVAL]
while QVALS[-1] < MAX_QVAL:
    QVALS.append(QVALS[-1] * STEP_QVAL)
OUTLIER_FILT_KNN_ICA = config.get("OUTLIER_FILT_KNN_ICA")
OUTLIER_MAX_DIST_ICA = config.get("OUTLIER_MAX_DIST_ICA")
ONT = config.get('ONT_GRID','BP')
ICA_VERSION = 1
GRID_INDIV_RANDOM_SEEDS_ICA = [random.sample(range(0,100000,1),k=max(REPS)) for x in OVERALL_REPS]

if config.get("is_test",False):
    REPS = [1,2]
    OVERALL_REPS = [1,2]
    COMPONENTS = [5,10,15]
    QVALS = [0.001,0.01,0.1]
    ONT = "CC"

rule all:
    input:
        expand("results/finalized/{g}/{d}",g=config.get('SCRNA_GROUPS'), d=['obs','var','expr','scaled','grid_enr','grid_silhouette']),

rule all_scanpy:
    input:
        expand("results/scanpy/{g}/celltypes.h5ad",g = config.get('SCRNA_GROUPS'))

rule all_gep_grid:
    input:
        expand("results/gep-grid-search/{g}/ica/{c}/{ovr}/consensus-ica.csv.gz", g=config.get('SCRNA_GROUPS'),c=COMPONENTS, ovr=OVERALL_REPS),
        expand("results/gep-grid-search/{g}/ica/{c}/{ovr}/consensus-usage.csv.gz", g=config.get('SCRNA_GROUPS'), c=COMPONENTS, ovr=OVERALL_REPS),
        expand("results/gep-grid-search/{g}/enr-metrics.csv", g=config.get('SCRNA_GROUPS')),
        expand("results/gep-grid-search/{g}/{im}.csv", g=config.get('SCRNA_GROUPS'),im=['dists','silhouette'])

rule all_gep:
    input:
        expand("results/gep/{g}/{k}/consensus-ica-modules.json",g = config.get('SCRNA_GROUPS'), k = config.get("COMPS_ICA")),
        expand("results/gep/{g}/{k}/consensus-ica-enrichment-{o}.csv.gz",g = config.get('SCRNA_GROUPS'), k = config.get("COMPS_ICA"), o=config.get('ONTS'))



rule all_isoseq_1:
    input:
        #expand("results/fastq-dump/{s}/",s=[x.sample_name for x in pep.samples if x.assay == "ISOseq"]),
        #expand("results/isoseq-1/mm2/{s}.{z}", z=['sam'],s=[x.sample_name for x in pep.samples if x.assay == "ISOseq"]),
        #expand("results/isoseq-1/flnc/{s}.bam",s=[x.sample_name for x in pep.samples if x.assay == "ISOseq"]),
        #expand("results/fastqc/{s}",s=[x.sample_name for x in pep.samples if x.assay == "ISOseq"])
        #expand("results/isoseq-1/pbmm2/{s}/{s}.bam",s=[x.sample_name for x in pep.samples if x.assay == "ISOseq"]),
        expand("results/isoseq-1/isoseq_collapse/{s}.gff",s=[x.sample_name for x in pep.samples if x.assay == "ISOseq"]),
        #expand("results/isoseq-1/cupcake-fusion/{s}/{s}.fusion.gff",s=[x.sample_name for x in pep.samples if x.assay == "ISOseq"]),

rule all_chipseq:
    input:
        expand("results/chipseq/aln/{s}/{s}.rmdup.bam.bai",s=[x.sample_name for x in pep.samples if x.assay == "CHIPseq"]),
        #expand("results/chipseq/aln/{s}/{s}_input.bam",s=[x.sample_name for x in pep.samples if x.assay == "CHIPseq"]),

rule all_srnaseq:
    input:
        #expand("results/srna/trimmed/{s}/{s}.srt.bam.bai",s=[x.sample_name for x in pep.samples if x.assay == "sRNAseq"]),
        #expand("results/fastqc/{s}",s=[x.sample_name for x in pep.samples if x.assay == "sRNAseq"]),
        expand("results/small-rna/shortstack-clean/{s}/{s}.bam.bai",s=[x.sample_name for x in pep.samples if x.assay == "sRNAseq"]),


include: "rules/finalize.smk"
include: "rules/custom-genome.smk"
include: "rules/cellranger.smk"
include: "rules/common.smk"
include: "rules/isoseq-1.smk"
include: "rules/chipseq.smk"
include: "rules/small-rnas.smk"
include: "rules/process-with-scanpy.smk"
include: "rules/gep.smk"
include: "rules/gep-grid-search.smk"
